<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>JS / TS Intro</title>

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="reveal/reset.css">
		<link rel="stylesheet" href="reveal/reveal.css">
		<!-- <link rel="stylesheet" href="reveal/theme/black.css" id="theme"> -->
		<link rel="stylesheet" href="reveal/theme/solarized.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="reveal/plugin/highlight/monokai.css" id="highlight-theme">
		<!-- <link rel="stylesheet" href="reveal/plugin/highlight/zenburn.css" id="highlight-theme"> -->

		<style>

	.reveal h1,
	.reveal h2,
    .reveal h3,
    .reveal h4 {
		font-family: 'Calibri', sans-serif;
		letter-spacing: -2px;

			font-weight: bold;
			color: black;
			font-style: italic;
			text-transform: none !important;
    }


    .reveal pre code {
      max-height: 1000px !important;
    }

	.todo:before {
      content: 'TODO: ';
    }

    .todo {
      color: red !important;
    }


		</style>
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">


<section data-markdown>
# Basics of JavaScript and TypeScript


</section>

      <section data-markdown class="todo">
        
### Basics
- Übungen reinbauen als Playground Links
- readonly 
- https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html

### Advanced
- 
-  Advanced Types und Utility Types von TypeScript
   - https://www.typescriptlang.org/docs/handbook/advanced-types.html
   - https://www.typescriptlang.org/docs/handbook/utility-types.html


</section>

      <section data-markdown>
          
## ES5: Classic JavaScript


</section>

                    <section>
                        <h2>Hello World: Markup und DOM</h2>
                        <pre><code class="xml" contenteditable>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello World!&lt;/title&gt;
  &lt;/head&gt;
    &lt;body&gt;
      &lt;div id="log">&lt;/div>
      &lt;script&gt;
          var element = document.getElementById("log");
          element.innerHTML = "&lt;h1>Hello World&lt;/h1>";
      &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
                        </code></pre>
                    </section>

                    <section>
                        <h3>Hello World: API</h3>
                        <pre><code class="xml" contenteditable>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;script&gt;
    document.title = 'Hello World 3';
    var div = document.createElement('div');
    var h1 = document.createElement('h1');
    h1.textContent = 'Hello World';
    div.appendChild(h1);
    document.body.appendChild(div);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
                        </code></pre>
                    </section>
                    <section>
                        <h2>Hello World: node</h2>
                        <pre><code class="hljs" data-trim data-line-numbers>
node -e "console.log('Hello World');"
                        </code></pre>
					</section>
					
                   <section>
                        <h2>Hello World: DevTools</h2>
                        <img src="img/Devtools-Screenshot.png">
                    </section>

<section data-markdown>
    
### Basics
      
</section>

                <section id="basis">
                    <h2>Object</h2>
                        <pre><code class="javascript" contenteditable>let map = {
    feld1: 'Huhu',
    zweites$Feld: "Auch sowas geht!"
};
console.log(typeof map === "object"); // true
console.log(map.feld1); // Huhu
console.log(map["zweites$Feld"]); // possible as well

map.hund = "Ganz neu geht auch";
map.f = function() { return "Aha!" };

delete map.hund; // delete
console.log(map.hund); // undefined
</code></pre>
                </section>
                <section>
                    <h2>Runtime Types</h2>
                        <pre><code class="javascript" contenteditable>let string = "String";
typeof string === "string";

let int = 1;
typeof int === "number";

let float = 1.0;
typeof float === "number";

let bool = true;
typeof bool === "boolean";

let func = function() {};
typeof func === "function";

typeof doesNotExist === "undefined";</code></pre>
                </section>

                <section>
                    <h2><code>==, ===</code></h2>
    <pre><code class="javascript" contenteditable>// == tries conversions, will confuse you`
"dog" == "dog";
1 == true;
2 != false;
2 != true;
0 == false;
-1 != false;
-1 != true;
1 == "1";
1 == "1.0";

// === without conversion, always take this
"dog" === "dog";
1 !== true;
1 !== false;
1 === 1;
1 !== "1"</code></pre>
            </section>


                <section>
                    <h2>undefined and null</h2>
    <pre><code class="javascript" contenteditable>let obj = {
    a: null,
    b: undefined,
    d: "d",
    e: "e"
};

typeof obj.a; // => "object"
typeof obj.b; // => "undefined"
typeof obj.c; // => "undefined"

obj.d = null;
typeof obj.d; // => "object"

obj.e = undefined;
typeof obj.e; // => "undefined"</code></pre>
                </section>


                <section>
                    <h2>Array</h2>
                        <pre><code class="javascript" contenteditable>
let array = ["a", "b", "c"];
let el = array[2];
array[1] = 20;
typeof array === "object";
// adds 4
array.push(4);
// at pos 1 remove 2 elements
array.splice(1, 2);
// at pos 1 remove 0 elements and insert "x"
// Zudem wird an Position 1 "x" hinzugefügt
array.splice(1, 0, "x");                        </code></pre>
                </section>

                <section>
                    <h2>string</h2>
<pre><code class="javascript" contenteditable>let s1 = 'Hallo, ';
let s2 = "Olli's Oma";

let s3 = s1 + s2;
s3 === "Hallo, Olli's Oma";

s3[1] === "a";
s3.charAt(1) === s3[1];
</code></pre>
                </section>

                <section>
                    <h2>Functions</h2>
                        <pre><code class="javascript" contenteditable>
function f2() {
    console.log("Called!");
}
let result2 = f2();
result2 === undefined;

let f1 = function(p1, p2) {
    return p1 + p2;
};
let result1 = f1(1,2);
result1 === 3;
                        </code></pre>
                </section>

<section data-markdown>
  
## Modern JavaScript

Talking about ES6 and later

</section>

  <section data-markdown>
    
<h2>After JS5: Reference</h2>

* https://exploringjs.com/es6/ (ES2015)
* https://exploringjs.com/es2016-es2017.html
* https://exploringjs.com/es2018-es2019/index.html
* https://exploringjs.com/tackling-ts/index.html
* https://kangax.github.io/compat-table/es2016plus/
    </a>
  
</section>

<section>
    <h2>Build Process</h2>
    <ul>
        <li>ES6, 7, 8 - und JSX-Code must be converted to ES 5/6
        <li>Tools
            <ul><li>Babel (Compiler)
                <li>Webpack (Bundler)
                <li>Webpack Dev Sever (HTTP Server with Hot Reload)
                </ul>
    </ul>
</section>

<section>
  <h4>ES2020: nullish coalescing operator</h4>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
console.log(null || 'right');
// right
console.log(undefined || 'right');
// right
console.log("" || 'wrong');
// wrong
console.log(0 || 'wrong');
// wrong
console.log(false || 'wrong');
// wrong
</code></pre>
  
<pre class="fragment"><code class="javascript" contenteditable data-trim>
console.log(null ?? 'right');
// right
console.log(undefined ?? 'right');
// right
console.log("" ?? 'wrong');
// ""
console.log(0 ?? 'wrong');
// 0
console.log(false ?? 'wrong');
// false
  </code></pre>
  <small>
<a href='https://www.typescriptlang.org/play?#code/PTAEDsFcBtoSwM4AtQGMD2BDaBTBq5wBzUdABxwCdMAXdSgWACgRQkaayEAuEAExwA3HNHJUAdAFt0ALzixM4+kWA5wAWgCqAZWB90qBMADqOAEbAAUpkGZtqSnDI1gAJRwAzKmtQ5gAeQpqOkojADkYeGQAfQxsPAJiaLFg+mZmDHAEdFxxUSIACgByAB8S0iDaeiKASgBuDPQsnJw89EKoWFAy0CLHInZahpYwfvZG5tz8gshwAQ9CHD5u8r64AZoh5lYxmgnsqfaCgCJjld6Ad0omoi2R0Cub-Za2woAGc6LH4jvWb6JnodCh5sAgcJ9-r8wP90kxAa1pvV4a9igB+VEVKhVSh3TIHBFHTrQUDo3q7KGgXbI6azeaLZaktYbClUph4l7TU4kjFfa4-JH3U7Uo4fRmQgWsN7C4Gg8Fivm3CVgEHQMHMIA'>
Try in Playground
</a>  </small>
</section>

            <section>
                <h3>ES6: Classes</h3>
                <pre class="fragment"><code class="javascript" contenteditable>class Person {
    constructor(name) {
        this._name = name;
    }
    get name() {
        return this._name;
    }
}
class Programmer extends Person {
    constructor(name, language) {
        super(name);
        this.language = language;
    }
    code() {
        return this.name + " codes in " + this.language;
    }
}</code></pre>
                <pre><code class="javascript" contenteditable>const programmer = new Programmer('Erna', 'JavaScript');
console.log(programmer.code());
console.log(programmer instanceof Programmer); // true
console.log(programmer instanceof Person); // true</code></pre>
            </section>

            <section>
            <h3>ES6: Arrow Functions</h3>
            <pre><code class="javascript" contenteditable>const displayInPage = (text) => {
   return document.body.innerHTML +=
       `${text}<br>`;
};</code></pre>
            <pre class="fragment"><code class="javascript" contenteditable>const displayInPage = text => document.body.innerHTML += `${text}<br>`;
</code></pre>
        </section>

        <section>
            <h3>ES6: Extended Object Literals</h3>
   <pre><code class="javascript" contenteditable data-trim>
const name = 'Oma';
const person = {
    // ES5: name: name
    name,
    // ES5: toString: function()
    toString() {
        return this.name;
    }
};
console.log(person.name); // Oma
console.log(person.toString()); // Oma
   </code></pre>
        </section>


                    <section>
                        <h2>ES6: Modules, Imports und Exports</h2>
                    </section>
                    <section>
                        <h3>ES6: Export of a single class</h3>
   <pre><code class="javascript" contenteditable>// Person.js
class Person {
  // ...
}
export default Person;
   </code></pre>
                    </section>
                    <section>
                        <h3>ES6: Import</h3>
   <pre><code class="javascript" contenteditable>// Programmer.js
import Person from './Person';

export default class Programmer extends Person {
  // ...
}
   </code></pre>
                    </section>
                    <section>
                        <h3>ES6: Named Export and Import</h3>
   <pre><code class="javascript" contenteditable data-trim>// util.js
export function displayInPage(text) {
    document.body.innerHTML +=
        `${text}<br>` ;
}
// or
export { displayInPage };
   </code></pre>
   <pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage} from "./util";
displayInPage('Hello, World');
   </code></pre>
   <pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage as display} from "./util";
display('Hello, World');
   </code></pre>
   <pre class="fragment"><code class="javascript" contenteditable data-trim>import * as util from "./util";
util.displayInPage('Hello, World');
   </code></pre>
                    </section>

                    <section>
                        <h3>ES6: Destructuring of Objects</h3>
   <pre><code class="javascript" contenteditable data-trim>
const person = {
  name: 'Olli',
  address: {
    city: 'Hamburg'
  },
  email: 'oliver.zeigermann@gmail.com'
};</code></pre>
   <pre class="fragment"><code class="javascript" contenteditable data-trim>
const {name, notThere} = person;
console.log(`name=${name}`);
// name=Olli
console.log(`notThere=${notThere}`);
// notThere=undefined
</code></pre>
   <pre class="fragment"><code class="javascript" contenteditable data-trim>
const {address: {city}} = person;
console.log(`city=${city}`);
//city=Hamburg
</code></pre>
                    </section>

                    
                    <section>
                        <h3>ES6: Destructuring of Parameters</h3>
   <pre><code class="javascript" contenteditable data-trim>
const person = {
  name: 'Olli',
  address: {
    city: 'Hamburg'
  },
  email: 'oliver.zeigermann@gmail.com'
};</code></pre>
   <pre class="fragment"><code class="javascript" contenteditable data-trim>
function print({email: contact}) {
    console.log(`contact=${contact}`);
}
print(person);
// contact=oliver.zeigermann@gmail.com
</code></pre>
   <pre class="fragment"><code class="javascript" contenteditable data-trim>
function g({name: x, y, z=10}) {
  console.log(`x=${x}`); // x=olli
  console.log(`y=${y}`); // y=undefined
  console.log(`z=${z}`); // z=10
}
g({ name: 'olli' });
</code></pre>
                    </section>
                    <section>
                        <h3>ES6: Destructuring of Arrays</h3>
   <pre><code class="javascript" contenteditable>const [a, b] = [1, 2];
console.log(`a=${a}`);
// a=1
console.log(`b=${b}`);
// b=2
</code></pre>
   <pre class="fragment"><code class="javascript" contenteditable data-trim>
const [, b] = [1, 2];
console.log(`b=${b}`);
//b=2
</code></pre>
                    </section>
                    <section>
                        <h3>ES6: for..of</h3>
          <p><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">
            Iterate over everything that is 'iterable'
    </a>
    </p>

   <pre><code class="javascript" contenteditable>for (const e of array2) {
    console.log(e);
}
// Hi
// Olli
// how are you
// ?
</code></pre>
                    </section>

    <section>
                        <h3>ES6: Spread-Operator</h3>
          <p><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">
            Everything that is 'iterable' can be transformed into single parameters    </a>
    </p>
   <pre><code class="javascript" contenteditable data-trim>
const array1 = ['Olli', 'how are you'];
const array2 = ['Hi', ...array1, '?'];
console.log(array2);
// => ["Hi", "Olli", "how are you", "?"]
</code></pre>
   <pre class="fragment"><code class="javascript" contenteditable  data-trim>
console.log(...array1);
// => Hi Olli how are you ?
</code></pre>
                    </section>

                    <section>
                      <h3>ES2018: Spread in object literals</h3>
 <pre><code class="javascript" contenteditable data-trim>
 const obj1 = { foo: 'bar', x: 42 };
 const obj2 = { foo: 'baz', y: 13 };
 const mergedObj = { ...obj1, ...obj2 };
 console.log(mergedObj)
 // { foo: "baz", x: 42, y: 13 }
 </code></pre>
                  </section>


                    <section>
                      <h3>ES6: Template Literals</h3>
        <p><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings">
       Multi-Line String-Literals with Gaps
  </a>
  </p>

 <pre><code class="javascript" contenteditable>const person = 'Oma';
const language = 'Haskell';

console.log(`${person} programs
${10 * 1024 * 1024} lines of code
in ${language}.`);
// Output:
// Oma programs
// 10485760 lines of code
// in Haskell.
</code></pre>
                  </section>

                  <section>
                    <h3>Tagged Template Literals</h3>
        <p><a target="_blank" href="http://exploringjs.com/es6/ch_template-literals.html#_tagged-templates">
       Mini-DSLs: Template-Literals with tag
  </a>
  </p>

     <pre><code class="javascript" contenteditable data-trim>
const expanded = tag`${person} codes in ${language}.`;
console.log(expanded);
//whatever you want
</code></pre>


 <pre class="fragment"><code class="javascript" contenteditable data-trim>
function tag(strings, ...values) {
console.log(strings);
//[ '', ' codes in ', '.' ]
console.log(values);
//[ 'Oma', 'Haskell' ]
return 'whatever you want';
}
</code></pre>

                  </section>

                <section>
                    <h2>fetch</h2>
                    <p>Browser API to load and save data</p>
                </section>
            <section>
            <h3>fetch as a simple GET</h3>
            <pre><code class="javascript" contenteditable>const url = `${BACKEND_URL}${path}`;
    
    fetch(url)
        .then(response => response.json())
        .then(json => /* ... */)
        .catch(ex => console.error('request failed', ex));
    </code></pre>
            </section>
    
            <section>
                <h3>fetch sending JSON using POST</h3>
                <pre><code class="javascript" contenteditable>const url = `${BACKEND_URL}${path}`;
const objectBeSaved = ...;

fetch(url, {
    method: 'POST',
    headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
    },
    body: JSON.stringify(objectBeSaved)
})
.then(json => response.status === 201 ? /* success */ :
                                        /* failure */)
.catch(ex => console.error('request failed', ex));
    </code></pre>
    
            </section>
    
            <section>
                <h2>Promises</h2>
            </section>
                        <section>
                            <h3>A Promise will resolve to a value, be rejected or abort with an error</h3>
                            <ul>
                                <li class="fragment">If it resolves this might be right now or in the future</li>
                                <li class="fragment">In any case a reaction will be asynchronous</li>
                            </ul>
                        </section>
    
                    <!-- <section>
                            <h3>Create a Promoise and react asynchronously</h3>
       <pre class="fragment"><code class="javascript" contenteditable>const promise = new Promise(resolve =>
        setTimeout(
            () => resolve('Result from promise'),
            1000)
    );
    </code></pre>
        <pre><code class="javascript" contenteditable>promise.then(value => console.log(value));
    // Output after 1 second: Result from promise
    </code></pre>
                        </section>
                        <section>
                            <h3>Chaining Execution</h3>
       <pre><code class="javascript" contenteditable>const promise = new Promise(resolve =>
        setTimeout(
            () => resolve('Result from promise'),
            1000)
    );
    </code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>// then returns a new promise
    const promise2 = promise.then(value => `${value} plus stuff`);</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>promise2.then(value => console.log(value));
    // Output after 1 second: Result from promise plus stuff
    </code></pre>
                        </section>
                <section>
                    <h3>Errors abort the rest of the chain</h3>
                    <p class="fragment">Unfortunately, such an error will be swallowed if you do not react to it</p>
                </section>
    
                        <section>
                            <h3>Catch Clause</h3>
       <pre><code class="javascript" contenteditable>Promise
        // creates and directly resolves promise
        .resolve('Result from promise')
        .then(x => {
            // this will be printed
            console.log(x);
        })
        .then(() => {
            console.log('This will be printed');
        })
        // this will NOT be printed as no error occured
        .catch(e => console.log('error: ', e))
    
    // Output:
    // Result from promise
    // This will be printed</code></pre>
                        </section>
                        <section>
                            <h3>Catch Clause when there is an error</h3>
       <pre><code class="javascript" contenteditable>Promise
        // creates and directly resolves promise
        .resolve('Result from promise')
        .then(x => {
            // this will be printed
            console.log(x);
            throw new Error('Something went wrong');
        })
        .then(() => {
            console.log('This will NOT be printed');
        })
        // this will be printed
        .catch(e => console.log('error: ', e))
    
    // Output:
    // Result from promise
    // error:  [Error: Something went wrong]</code></pre>
                        </section>
                        <section>
                            <h3>Catch Clause when Promise is rejected</h3>
       <pre><code class="javascript" contenteditable>Promise
        // creates and directly rejects promise
        .reject('Promise rejected')
        .then(x => {
            // this will NOT be printed
            console.log(x);
        })
        .then(() => {
            console.log('This will NOT be printed');
        })
        // this will be printed
        .catch(e => console.log('error: ', e))
    
    // Output:
    // error:  Promise rejected</code></pre>
                    </section> -->
<section data-markdown>
    
### ES2017: From Callback to Promise to async/await

<small>https://twitter.com/addyosmani/status/1097035418657144832</small>


</section>

      <section>
        <h3>fetch with async/await</h3>

        <em>async/await recommended alternative to explicit Promise</em>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
async function loadGreetings() {          
  try {
    const response = await fetch('http://localhost:7000/greetings');
    const json = await response.json();
    // success: do something with json
  } catch (err) {
    console.error("Loading failed: ", ex);
  }
}
  </code></pre>

      </section>

<section data-markdown id='ts'>
    
## TypeScript

</section>


<section id="t-typescript-grundlagen">
	<h2>Einführung: Die Sprache TypeScript</h2>
	<p class="fragment">
	  <em>TypeScript is a superset of JavaScript that compiles to plain JavaScript </em>(
	  <a href="http://www.typescriptlang.org/" target="_blank"
		>http://www.typescriptlang.org/</a
	  >)
	</p>
	<ul>
	  <li class="fragment">Erweitert JavaScript um ein Typen System</li>
	  <li class="fragment">
		Jeder gültige JavaScript Code ist auch gültiger TypeScript Code
	  </li>
	  <li class="fragment">
		Mittels des TypeScript Compilers wird aus TS Code JavaScript Code
	  </li>
	</ul>
  </section>

  <section>
	<h3>TypeScript Grundlagen</h3>
	<p>Typ-Angaben werden hinter einen Bezeichner geschrieben</p>
	<pre class="fragment"><code class="typescript" contenteditable data-trim>
// Variablen können Typ-Informationen bekommen
let foo: string;
foo = 'yo';
// Error: number: This type is incompatible with string
foo = 10;
		   </code></pre>
	<pre class="fragment"><code class="typescript" contenteditable data-trim>
// Funktionen
function sayIt(what: string): string {
return `Saying: ${what}`;
}

sayIt('Klaus'); // ok
sayIt(10); // error
</code></pre>

	<pre class="fragment"><code class="typescript" contenteditable data-trim>
// Arrow Funktionen
const sayIt = (what: string): string => `Saying: ${what}`;

sayIt('Moin');
sayIt(123); // Error: Argument of type '123' is not assignable
		// to parameter of type 'string'.
</code></pre>
  </section>

  <section>
	<h2>Eingebaute Typen</h2>
	<pre class="fragment"><code class="typescript" contenteditable data-trim>
// string
let city: string = 'Hamburg';

// boolean
let isDone: boolean = false;

// number
let theAnswer: number = 42;

// array (note the [])
let cities: string[] = ['Hamburg', 'Barcelona'];
// alternative:
let languages: Array&lt;string> = ['JavaScript', 'TypeScript'];

// void
function log(s: string): void { /* ... */ }
		</code></pre>
  </section>
  <section>
	<h2>Eingebaute Typen: any und unknown</h2>
	<pre class="fragment"><code class="typescript" contenteditable data-trim>
// any: kann alle Typen aufnehmen, Typ-Prüfung ist ausgeschaltet
let theUnknown: any = 'Who cares';
theUnknown = 666; // ok
theUnknown = true; // ok
let a: number = theUnknown; // ok
function loadData(): any { return "" // ok }
let b:number = loadData(); // ok

		</code></pre>
  </section>
  <section>
	<h2>Eingebaute Typen: any und unknown</h2>
	<pre class="fragment"><code class="typescript" contenteditable data-trim>
// unknown: kann ebefalls alle Typen aufnehmen, erzwingt aber vor der Verwendung Typ-Prüfung
function loadData(): unknown { return "" // ok }
let b = loadData(); 
b.toUpperCase(); // ERROR
if (typeof b === "string") {
// b ist jetzt string (typeof ist Laufzeitprüfung!)
b.toUpperCase(); // OK
}
		</code></pre>
  </section>
  <section>
	<h2>Typen können abgeleitet (inferred) werden</h2>
	<pre class="fragment"><code class="typescript" contenteditable data-trim>
let city = 'Hamburg'; // city ist ein String

city = 42;
// Fehler: [ts] Type '42' is not assignable to type 'string'.
</code></pre>
	<pre class="fragment"><code class="typescript" contenteditable data-trim>
// Explizite Angabe eines Types (parameter)
// und abgeleiteter Typ (Return Type der Funktion)

function sayIt(what: string) {
return `Saying: ${what}`;
}

const said: string = sayIt('Hello TypeScript'); // ok
const saidItWrong: number = sayIt('Hello TypeScript'); // error!


</code></pre>
  </section>

  <section>
	<h2>Type Check ausschalten</h2>
	<p>
	  Mit <code>@ts-ignore</code> (als Kommentar) kann wird die Überprüfung der nächsten Zeile
	  ausgeschaltet:
	</p>
	<pre><code class="typescript" contenteditable data-trim>
let city:string = "Hamburg";

city = 20259; // error: [ts] Type '20259' is not assignable to type 'string'.

// @ts-ignore
city = 20259; // ok                
</code></pre>
	<p class="fragment">
	  Nützlich in corner cases, die nur schwer mit TypeScript abbildbar sind oder bei
	  Migration
	</p>
  </section>
  <section>
	<h2>null und undefined</h2>
	<div class="fragment">
	  <p><code>null</code> muss explizit zugelassen werden <em>(strictNullChecks</em>):</p>
	  <pre><code class="typescript" contenteditable data-trim>
let city:string = null; //Type 'null' is not assignable to type 'string'.

let optionalCity:string|null = null; // OK
		</code></pre>
	</div>
	<div class="fragment">
	  <p><code>undefined</code> muss ebenfalls explizit zugelassen werden:</p>
	  <pre><code class="typescript" contenteditable data-trim>
let city:string = undefined; //Type 'undefined' is not assignable to type 'string'.

let optionalCity:string|undefined = undefined; // OK
let optionalCity:string|undefined|null = null; // OK
		  </code></pre>
	</div>
	<div class="fragment">
	  <p>
		Optionale Parameter können mit ? gekennzeichnet werden (erlauben dann auch
		<code>undefined</code>)
	  </p>
	  <pre class="fragment"><code class="typescript" contenteditable data-trim>
function greet(name: string, greeting?: string) {
console.log(`${greeting || 'Hello'}, {name}`);
}

greet('Susi', 'Moin')// Moin, Susi

// 2. Parameter ist optional:
greet('Klaus'); // Hello, Klaus

greet('Peter', null); // Argument of type 'null' is not assignable
				  // to parameter of type 'string | undefined'.
		</code></pre>
	</div>
  </section>

  <section>
	<h2>Eigene Typen</h2>
	<p>
	  Mit <code>interface</code> und <code>type</code>können eigene Typen (Objekt-Strukturen)
	  definiert werden:
	</p>

	<pre><code data-trim contenteditable class="typescript" data-leftpad>
// Komplexer Typ
interface Person {
name: string; // Pflicht
livesIn?: string; // Optional
}

// Alternativ (interface und type fast synonym)
type Person = { name: string; livesIn?: string; }

const susi: Person = { // OK
name: 'Klaus',
livesIn: 'Hamburg'
};
const klaus: Person = { // OK (livesIn ist optional)
name: 'Klaus'
}

const helmut: Person = {} // Error: Property 'name' is missing

const lukas: Person = {
name: 'Lukas',
profession: 'Lokführer'
} // Error: 'profession' does not exist in type 'Person'.
		   </code></pre>
  </section>

  <section>
	<h2>Eigene Typen II</h2>
	<p>Eigene Objekt-Typen können sowohl "Attribute" als auch Funktionen enthalten:</p>
	<pre><code data-trim contenteditable class="typescript" data-leftpad>
	  // Komplexer Typ
	  type Person {
		name: string; // Pflicht
		greet(greeting: string): string;
	  }

	  const p:Person = {
		name: "Klaus",
		greet(greeting: string) { 
		  return `${greeting}, ${this.name}`
		}
	  }
	  p.greet("Hello"); // OK
	  p.greet(123); // ERR: Argument of type '123' is not 
					// assignable to parameter of type 'string'.

	  const wrong:Person = {
		name: "Susi", // OK
		greet(greeting: number) { return "hello" } 
		  // ERR: Type '(greeting: number) => string' is not assignable to 
		  //      type '(greeting: string) => string'.
		  //      Types of parameters 'greeting' and 'greeting' are incompatible.
		  //      Type 'string' is not assignable to type 'number'.
	  }
					 </code></pre>
  </section>
  <section>
	<h2>Union Types</h2>
	<p>Variablen, Parameter etc. können mehr als einen Typ annehmen:</p>
	<pre><code data-trim contenteditable class="typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

function printNameOrTitle(obj: Person | Movie) { 

console.log(obj.title); // ERR: Property 'title' does not 
					// exist on type 'Person | Movie'

if ("title" in obj) { // Abfrage ist ein "Type Guard"
// obj ist Movie hier, title ist definiert
console.log(obj.title);
} else {
// obj ist Person hier: name ist definiert
console.log(obj.name);
}
}

printNameOrTitle({name: "Klaus"}); //OK
printNameOrTitle({title: "Pulp Fiction"}); //OK
printNameOrTitle({label: "Save"}); // ERR

	</code></pre>
  </section>
  <section>
	<h2>Type Guards</h2>
	<p>Durch einen Type Guard können Typen "eingeengt" werden</p>
	<pre><code data-trim contenteditable class="typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

// Wenn diese Funktion true zurueckgibt, nimmt Typescript an,
// dass das übergebene Argument vom Typ Movie ist
function isMovie(candidate: any): candidate is Movie {
return ("title" in candidate);
}

function printNameOrTitle(obj: Person | Movie) { 
if (isMovie(obj)) {
// movie
}
}

	</code></pre>
  </section>
  <section>
	<h2>Type Assertions</h2>
	<pre><code data-trim contenteditable class="typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

// Wenn diese Funktion zurueckkehrt (kein Error geworfen wird) nimmt Typescript an,
// dass das übergebene Argument vom Typ Movie  ist
function assertIsMovie(candidate: any): asserts candidate is  Movie {
if ("title" in candidate) {
return;
}
throw new Error("Candidate is not a movie!")
}

function printTitle(hopefullyAMovie: any) { 
assertPersonIsMovie(hopefullyAMovie)
// hopefullyAMovie ist jetzt Movie
hopefullyAMovie.title; // OK
}

	</code></pre>
  </section>
  <section>
	<h2>String Literal Types</h2>
	<p>Beispiel: String Aufzählungstyp</p>
	<pre><code data-trim contenteditable class="typescript" data-leftpad>
// Beispiel:             
type View = "POST_LIST" | "POST_EDITOR";

const s:View = "POST_LIST"; // OK
const t:View = "POST_LISTE" // FEHLER

function setView(v: VIEW) {
if (v === "POST_LIST") { ... } // ok
if (v === "POST_LISTE") { ... } // error: immer false
}

setView("POST_LIST"); //OK
setView("POST_LISTE"); // ERROR
	</code></pre>
  </section>

<section>
    <h2>Why using type systems?</h2>
    <div class="fragment">
        <h3>type systems make code easier to maintain</h3>
        <p >type annotations / inferred types</p>
        <ul >
            <li>can make code more readable
            <li>can make code easier to analyse
            <li>can allow for reliable refactoring (https://code.visualstudio.com/Docs/languages/typescript#_refactoring)
            <li>can allow for generally better IDE support
            <li>can catch some (type related) errors early
        </ul>
    </div>
    <p class="fragment"><a href="https://channel9.msdn.com/Events/Build/2016/B881" target="_blank">
        Anders Hejlsberg@Build2016: <em>Big JavaScript codebases tend to become "read-only".</em>
    </a></p>
</section>

<section>
    <h2>https://2019.stateofjs.com</h2>
    <p>Survey on the state of JavaScript</p>
</section>

<section>
<h3>JavaScript flavors</h3>
    <a href="https://2019.stateofjs.com/javascript-flavors/" target="_blank">
        <img src="img/2019_flavors.png" height="500">
    </a>
    <p><small><a href="https://2019.stateofjs.com/javascript-flavors/" target="_blank">
      https://2019.stateofjs.com/javascript-flavors/
    </a></small></p>
</section>

<section>
    <h2>TypeScript</h2>
    <h3 class="fragment">ease of use and tool support over soundness</h3>
    <ul class="fragment">
        <li>By Microsoft (Anders Hejlsberg)
        <li>Based on ES6/ES7/ES8/ES9/ES10
        <li>Adds optional type annotations, visibility, and decorators
        <li>Compiler checks and removes annotations
          <li>External declarations can add type information to pure JavaScript
        <li>Extensive support in Visual Studio Code and IntelliJ / Webstorm
        <li>supporting people from Java and C# land
    </ul>
</section>

<section data-markdown>
  
#### Behavior as known from Java/C#            

<img src='img/screenshot-typescript.png' class='part'>

Problems become visible at development time
<br>
Show References works reliably
<br>
Refactoring possible

        
</section>

<section data-markdown>
    
  
### There are two perspectives how to look at TypeScript

- TypeScript is a la language that compiles to JavaScript
- TypeScript is a tool that enhances JavaScript with an optional static type system
      
<small>
https://twitter.com/jbandi/status/1040518056051654659
</small>
    
  </section>
    
<section data-markdown>
  
### TypeScript for business applications

_All frameworks work well with TypeScript_

<img src='img/typescript.jpg' height="400px">

<small>
https://www.typescriptlang.org/
<br>
Vue 3.0 based on TypeScript https://twitter.com/newsyc250/status/1063900647853121536
<br>
Vue Roadmap: https://github.com/vuejs/vue/projects/6#column-4065494
</small>


</section>
  
<section data-markdown>
    

http://www.typescriptlang.org/

https://www.typescriptlang.org/play/index.html

https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript


</section>

<section>
    <h3>Basics</h3>
       <pre class="fragment"><code class="typescript" contenteditable data-trim>
// variables can have type information
let foo: string;
foo = 'yo';
// Error: Type 'number' is not assignable to type 'string'.
foo = 10;
</code></pre>
       <pre class="fragment"><code class="typescript" contenteditable data-trim>

// types can be inferred (return type)
function sayIt(what: string) {
return `Saying: ${what}`;
}
const said: string = sayIt(obj);

</code></pre>
       <pre class="fragment"><code class="typescript" contenteditable data-trim>
class Sayer {
what: string; // mandatory

constructor(what: string) {
    this.what = what;
}

// return type if you want to
sayIt(): string {
    return `Saying: ${this.what}`;
}
}
</code></pre>
  </section>

  <section>
      <h2>Nullability</h2>
      <p>One of my main sources of runtime exceptions when programming Java</p>
      <p><small>Even after many years it is still surprising how many corner cases I miss in complex code</small></p>
  </section>

  <section class="typescript">
      <h3>TypeScript</h3>
      <pre class="fragment"><code class="typescript" contenteditable data-trim>
function foo(num: number) {
  if (num > 10) {
    return 'cool';
  }
}
</code></pre>
      <pre class="fragment"><code class="typescript" contenteditable data-trim>
// check required
const fooed: string|void = foo(11);
if (fooed) {
  fooed.toString();
}
</code></pre>
      <pre class="fragment"><code class="typescript" contenteditable data-trim>
// or tell the compiler we know better (in this case we actually do)
fooed!.toString();
</code></pre>
      <div class="fragment">
          <p>Types are non-nullable by default in TypeScript</p>
          <p>All types nullable by default in TypeScript 1.x</p>
      </div>
  </section>

  <section data-markdown>
      
### Generic Type information

* Types can be parameterized by others
* Most common with collection types
* Generic Types in TypeScript are 
<a href="https://twitter.com/ahejlsberg/status/822882400724131841?s=03">always covariant</a> (more special):<br>
    parametric types are compatible if the type to assign from has a more special type parameter
* seems most intuitive, allows for obviously wrong code, though (more on that coming up next)

  </section>

  <section class="fragments">
      <h3>Generic Type information</h3>
      <p class="fragment">Types can be parameterized by others</p>
      <p class="fragment">Most common with collection types</p>
      <pre class="fragment"><code class="typescript" contenteditable data-trim>
let cats: Array&lt;Cat> = []; // can only contain cats
let animals: Array&lt;Animal> = []; // can only contain animals
</code></pre>
      <pre class="fragment"><code class="typescript" contenteditable data-trim data-num-start="3">
// nope, no cat
cats.push(10);
     </code></pre>
      <pre class="fragment"><code class="typescript" contenteditable data-trim data-num-start="5">
// nope, no cat
cats.push(new Animal('Fido'));
     </code></pre>
      <pre class="fragment"><code class="typescript" contenteditable data-trim data-num-start="7">
// cool, is a cat
cats.push(new Cat('Purry'));
     </code></pre>
      <pre class="fragment"><code class="typescript" contenteditable data-trim data-num-start="9">
// cool, cat is a sub type of animal
animals.push(new Cat('Purry'));
     </code></pre>
  </section>

  <section>
      <h4>TypeScript allows for birds and dogs to be cats here :)</h4>
         <pre class="fragment"><code class="typescript" contenteditable data-trim>
let cats: Array&lt;Cat> = []; // can only contain cats
let animals: Array&lt;Animal> = []; // can only contain animals
</code></pre>
         <pre class="fragment"><code class="typescript" contenteditable data-trim data-num-start="3">
// error TS2322: Type 'Animal[]' is not assignable to type 'Cat[]'.
//  Type 'Animal' is not assignable to type 'Cat'.
//    Property 'purrFactor' is missing in type 'Animal'.
cats = animals;
         </code></pre>
         <pre class="fragment"><code class="typescript" contenteditable data-trim data-num-start="7">
// wow, works, but is no longer safe
animals = cats;
         </code></pre>
         <pre class="fragment"><code class="typescript" contenteditable data-trim  data-num-start="9">
// because those are now all cool
animals.push(new Dog('Brutus'));
animals.push(new Animal('Twinky'));
         </code></pre>
         <pre class="fragment"><code class="typescript" contenteditable data-trim  data-num-start="12">
// ouch:
cats.forEach(cat => console.log(`Cat: ${cat.name}`));
// Cat: Purry
// Cat: Brutus
// Cat: Twinky
</code></pre>
    </section>

    <section>
        <h2>The flipside</h2>
        <p>This code is safe (as we access cats in a readonly fashion)</p>
        <pre><code class="typescript" contenteditable data-trim>
function logAnimals(animals: Array&lt;Animal>) {
  animals.forEach(animal => console.log(`Animal: ${animal.name}`));
}

logAnimals(cats);
</code></pre>
        <ul  class="fragment">
            <li>This works in TypeScript (and it should)</li>
            <li>however, potentially not safe, there is nothing to keep us from writing to cats</li>
        </ul>
        <div class="fragment">

        <p>much despised Java generics excel here as they can actually make that code safe (another difference:
            <a target="_blank" href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Comparing_declaration-site_and_use-site_annotations">
                Use-site variance
            </a>)
        </p>
        <pre><code class="java" contenteditable data-trim>
// Java
void logAnimals(List&lt;? extends Animal> animals) {
  animals.forEach(animal -> System.out.println("Animal: " + animal.name));
  // illegal:
  animals.add(new Animal("Twinky"));
}
</code></pre>
        </div>

    </section>

    <section>
      <h2>Union Types</h2>
      <p class="fragment">aka Disjoint Unions aka Tagged Unions aka Algebraic data types</p>
      <p class="fragment">to describe data with weird shapes</p>
      <p class="fragment">depending on some data other data might apply or not</p>
      <pre class="fragment"><code class="typescript" contenteditable data-trim>
// a disjoint union type with two cases
type Response = Result | Failure;

type Result = { status: 'done', payload: Object }; // all good, we have the data
type Failure = { status: 'error', code: number}; // error, we get the error code
     </code></pre>
     <small><a href='https://www.typescriptlang.org/play?q=423#example/union-and-intersection-types'>https://www.typescriptlang.org/play?q=423#example/union-and-intersection-types</a></small>
  </section>

  <section>
      <h3>Implementation in TypeScript</h3>
      <pre class="fragment"><code class="typescript" contenteditable data-trim>
function callback(response: Response) {
  // works, as this is present in both
  console.log(response.status);
  // does not work,
  // as we do not know if it exists, just yet
  console.log(response.payload); // ERROR
  console.log(response.code); // ERROR
     </code></pre>
      <pre class="fragment"><code class="typescript" contenteditable  data-trim data-num-start="7">
  switch (response.status) {
    case 'done':
        // this is the special thing:
        // type system now knows this is a Result
        console.log(response.payload);
        break;
    case 'error':
        // and this is a Failure
        console.log(response.code);
        break;
  }
}           </code></pre>
<small><a href='https://www.typescriptlang.org/play?jsx=0&ssl=16&ssc=1&pln=25&pc=2#code/PTAEENQEwSwZwFYHsYDsAuoCuqZNaOgJ4AOApqAO4zoAWhlSoAxuHGXALABQx5oAJQ4lQAXkEcsAG0wAfUADFwMKVgBOZANw8efCkLjTM4gN6g46cOixwAXKADkUfGQcAaUCXBEpScFHsAeQAjBDJmTABfTVAQCCkpUABzJCQoD0oKWnAANwo6CigrcF1SCiUVdQpTc0trO0cyNTUkNXcWNLJ7VCwAW2Cm6NiwJpa1DIokskwC0FHWjqgyHW4l5ilwDVApadANOBJ8dnsDEm1uOMY1AGs4DzZCWnhQZ5J9sgwXgmCkOh5mI5IHYAOl8SQAFPtDqh2MCLFYbABKc5xZwcUCoX5UVrXNw8OIPTLQJiYzDXTGUF4AMxemDIAA94Og7qAEDZMERpv9ASCwZDhEcyMCvD4-FBkcNQABRAQCQICbkwoFCvlQwXAgFLCVxGVyhXcHhwajoZj0fkHdXw+qI0Amf5sChOFwOWw8UDuyV0Z7PWYHcIwcCJL2oJKu7gez1lcxECxkXoYpCU8mJuCPb2pyAGIxuj0ApW8pAQtUwoUi3z+ZE593BDTga7nVjsRrNVouquS8CoKBp1PPSAVVQadt5uDK0GF83Q2GasiV8MemtkOvnSJAA'>Code in Playground</a></small>
  </section>

    <section>
        <h3>any type</h3>
        <p class="fragment">can be anything, not specified</p>
        <p class="fragment">can selectively disable type checking</p>
        <pre class="fragment"><code class="typescript" contenteditable data-trim>
function func(a: any) {
  return a + 5;
}
</code></pre>
        <pre class="fragment"><code class="typescript" contenteditable data-trim>
// cool
let r1: string = func(10);

// cool
let r2: boolean = func('wat');
</code></pre>

        <ul>
            <li class="fragment">explicit any supported, but any never inferred
            <li class="fragment">try to avoid

        </ul>
    </section>

    <section data-markdown>
      
### unknown and never type

_unknown_
* useful for APIs that want to signal “this can be any value, so you must perform some type of checking before you use it”
* no operations are permitted on an unknown
* anything is assignable to unknown
* unknown isn't assignable to anything but itself and any

_never_

<a href="https://www.typescriptlang.org/play?q=23#example/unknown-and-never">
Open in Playground
</a>

    </section>

    <section data-markdown>
        
### Is TypeScript like Java/C++/C#?</h2>

_not really_

* optionally typed / any
* built to match common JavaScript programming patterns
* semantically compatible with JavaScript
* type system more expressive
* type inference
* control flow based type analysis

    </section>

    <section>
        <h2>Structural vs Nominal Typing</h2>
        <ul>
            <li class="fragment">Nominal Typing: types are compatible when their declared types match
            <li class="fragment">Structural Typing: types are compatible when their structures match
            <li class="fragment">Java, C#, C++, C all use nominal typing exclusively
            <li class="fragment">Flow classes are also treated as nominal types
            <li class="fragment">TypeScript classes are treated as structural types
            <li class="fragment">Everything else in both Flow and TypeScript uses structural typing
            <li class="fragment elm">Elm always uses structural typing with exact matches on Records
        </ul>
    </section>

    <section>
        <h3>Structural Typing for Interfaces</h3>
        <pre><code class="typescript" contenteditable data-trim>
interface NamedObject {
  name: string;
}

// this is fine as nominal typing only applies to Flow classes
let namedObject: NamedObject = dog;

// same thing, also fine
let namedObject: NamedObject = {
  name: "Olli"
};

// not fine in either, missing name
let namedObject: NamedObject = {
  firstName: "Olli"
};
        </code></pre>
    </section>

    <section>
        <h3>Structural Typing for classes</h3>
        <pre><code class="typescript" contenteditable data-trim>
class Person {
  name: string;
}

class Dog {
  name: string;
}

let dog: Dog = new Dog();

// yes, correct, as structurally compatible
let person: Person = dog;

// same thing, also correct
let person: Person = {
  name: "Olli"
};

        </code></pre>
    </section>

    <section>
      <h3>Some Type Inference Magic</h3>
      <p>Consider</p>
      <pre><code class="typescript" contenteditable data-trim>
class Dog { woof() { } }

const animals = [];
animals.push(new Dog());
</code></pre>
      <div class="fragment">
          <p>both TypeScript and Flow know this is safe, as we have only added Dogs so far</p>
          <pre><code class="typescript" contenteditable data-trim data-num-start="5">
animals.forEach((animal: Dog) => animal.woof());
</code></pre>

      </div>
      <div class="fragment">
          <p>Adding Cats <em>later</em> and thus changing array type later</p>
          <pre><code class="typescript" contenteditable data-trim>
class Cat { meow() { } }
animals.push(new Cat());
</code></pre>
          <p>does not affect TypeScript (correct), but makes Flow fail</p>

      </div>
  </section>    

    <section>
        <h2>Classes in TypeScript</h2>
        <p class="fragment">TypeScript has special support for classes</p>
        <p class="fragment">Similar features can be found in Java/C++/C#</p>
        <ul class="fragment">
            <li><em>abstract</em> classes and methods
            <li>special shortcut constructors (combined definition of fields and initialization)
            <li>public, private, protected
            <li>decorators (aka <a  target="_blank" href="https://msdn.microsoft.com/en-us/library/z0w1kczw(v=vs.80).aspx">
            Attributes in C#
            </a> and <a target="_blank" href="https://docs.oracle.com/javase/tutorial/java/annotations/">
Annotations in Java</a>)
            <li>
                <a target="_blank"
                        href="https://blogs.msdn.microsoft.com/typescript/2016/09/22/announcing-typescript-2-0/">
                    readonly properties
        </a>
            <a target="_blank" href="https://msdn.microsoft.com/en-us/library/acdd6hb7.aspx">
                like in C#
            </a>
        </ul>
    </section>

    <section data-markdown>
        
### TypeScript Declaration fields

* Integration with raw JavaScript
* install external type declarations transparently <a href="https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/">using npm</a>
                        (e.g.<em>npm install @types/react --save</em>)
* If there are no existing declaration files: still works, but less powerful

    </section>

  <section>
      <h3 style="top: -30px; position: relative">Should you use a type checker?</h3>
      <ul class="fragment" style="top: -30px; position: relative">
          <li>don't be fooled: checkers do not make your programs error free
          <li><a target="_blank" href="http://danluu.com/empirical-pl/">there seems to be little or no impact on productivity</a>
          <li>initial effort to introduce a checker is low, though
          <li>but a type system is a complex thing, it comes at a cost
      </ul>
      <p class="fragment" style="top: -30px; position: relative">My biased recommendation</p>
      <ul class="fragment" style="top: -40px; position: relative">
          <li >your project does not live for long: <em >no</em>
          <li >your project is really simple: <em >no</em>
          <li >there is a chance you will need to refactor the thing: <em >yes</em>
          <li >your system is very important or even crucial for the success of your company: <em >yes</em>
          <li >people enter or leave your team frequently: <em >yes</em>
          <li >you have substantial amount of algorithmic code: <em >yes</em>
      </ul>
  </section>

  <section data-markdown id='advanced'>
    
## Advanced Topics


</section>

<section data-markdown id='type-vs-interface' style="font-size: x-large;">
  
## type vs interface

_Because an interface more closely maps how JavaScript objects work by being open to extension, we recommend using an interface over a type alias when possible._

_On the other hand, if you can’t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go_

https://www.typescriptlang.org/docs/handbook/advanced-types.html#interfaces-vs-type-aliases
https://www.typescriptlang.org/docs/handbook/2/objects.html#interfaces-vs-intersections

- pretty much mixable
- interfaces have better error messages and a clear position of definition: https://www.typescriptlang.org/play?q=240#example/types-vs-interfaces
- interfaces for libraries and types for user-code: https://twitter.com/orta/status/1307692799807164417


</section>

<section>
<h3>object literal type checking</h3>
<pre><code>
type Basic = {
  a: number;
  b: string;
}

type BasicAndMore = Basic;

const aha1: Basic = {
  a: 10,
  b: 'yo',
  c: true // nope, assuming you did this in error
};

// works
const aha2: Basic = {
  a: 10,
  b: 'yo',
  c: true
} as Basic;

const more = {
  a: 10,
  b: 'yo',
  c: true
}

// works as well
const aha3: Basic = more;
</code></pre>

<a href='https://www.typescriptlang.org/play?ssl=1&ssc=1&pln=29&pc=1#code/PTAEHsCMCsFMGMAuoA2BLRsBOBDFpEBPAB1lHgAsEBrNAOwHMBYAKCNNACEcBnNeUAF5QAb1ahQOAFyg6AVwC2kbAG5xoSDJ6Is9BmpYBfVq3ZlufeAEE6AEwCy4LGWEX+B1vHB1tkijgBGGTcBYTEWCWlQAIAGABp1TVAAckJwZISI8hkdOTIQWXBSOMkeHkU9UDS5UFs0WwIKNB5QelBsLCdWQw8WLx9kHH8AJmDefiFRdSjYzIkk1PS57IIsPO7SrnH4Xv7fBScXKayZ+MSZRYz1eBy12G6TPu9fIZwAZjHLSYPnXqA'>
  Code in Playground
</a>
</section>


<section data-markdown>
  
## Inversify IoC Container

- https://github.com/DJCordhose/inversify-playground
- Meta Data: https://www.typescriptlang.org/docs/handbook/decorators.html#metadata

</section>

<section data-markdown>
  
## type guards

- https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards
- https://www.typescriptlang.org/play?q=29#example/type-guards
- [our animal example](https://www.typescriptlang.org/play?target=7&jsx=0#code/LAKAxgNghgzjAEBBAdgSwLZQvA3qeB8YA9sjAC4BOArmOcZQBQAOlx5ApnRwCbyUcoPUhACe8ZFHQcAXPAqVUyAOYBKXPkIBfUDpChIsBABFiy+BwAenZDwQoMWDSELwA7sWIAzRurwvXQhIyYggOADoIM0YAAwASHHIAC1QYcMlpLXdPLxgY1U0CPT0DaDh4AGEocgtrDlt7NExsf1dpYjdfZ0Cg0hhQiKjlWITk1PSpDiz2tzyCgKLdUFAAehX4JPJyZhgZNbcD8PJRZg4YMEVmcmgVcIZlFeEwGBWkqFsAI08AaxWhADd3mBeABaY6nNKbdAQADE1BgHEoIJ4HC8SlB4I4IOU1CglDsoDCNXejggcgczXgAF4JBw3JVqowAOQABWolEooiZqgA3KBUF54IwAEQzYXwJTwEnNPyFIXSpywBnkVThGa+Jb6EAC+VNLBqjgdWULXWkqUIKoqg0dDUgEogLzUZB0VCkCUwS2MBVkpB6iCqOTe93K7r8DjkdnIU2UpWW1UzeAAQipNKdKLRyF4fLty3AfQGkWiqU93tU835gsYxcZpeNrm91s68yyHAgCNDBDW8BE4mYxDgqA+YXcSXq8GSiI4UoE8HTSlQnDE4483aurrI3eQS4gqG+HDlXaJUr9ckt8AAPvBTOYaZn6Z7WezOdzs64uw2PN5bXogA)

</section>

			</div>

		</div>

		<script src="reveal/reveal.js"></script>
		<script src="reveal/jquery-3.5.1.min.js"></script>
		<script>
			const isLocal =
			  window.location.hostname.indexOf("localhost") !== -1 ||
			  window.location.hostname.indexOf("127.0.0.1") !== -1;
	  
			if (isLocal) {
			} else {
			  // only applies to public version
			  $(".preparation").remove();
			  // $(".todo").remove();
			  $(".local").remove();
			  $(".presenter").remove();
			}
			Reveal.addEventListener("ready", function(event) {
			  $(".fragments li").addClass("fragment");
			  $(".no-fragments li").removeClass("fragment");
	  
			  // make all links open in new tab
			  $("a").attr("target", "_blank");
	  
			  if (isLocal) {
				// only applies to presentation version
				Reveal.configure({ controls: false });
			  } else {
				// only applies to public version
				$(".fragment").removeClass("fragment");
			  }
			});
			  // applies to all versions
			// $('section').attr('data-background-image', "backgrounds/sky.jpg");
			  $("code").attr("data-line-numbers", true);
			  $("code").attr("data-trim", true);
			  $("code").attr("contenteditable", true);
	  
		</script>
	  
		<script src="reveal/plugin/zoom/zoom.js"></script>
		<script src="reveal/plugin/notes/notes.js"></script>
		<script src="reveal/plugin/search/search.js"></script>
		<script src="reveal/plugin/markdown/markdown.js"></script>
		<script src="reveal/plugin/highlight/highlight.js"></script>


		<script>

			// Also available as an ES module, see:
			// https://revealjs.com/initialization/
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,
				width: "100%",
				height: "100%",


				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight ]
			});

		</script>

	</body>
</html>
